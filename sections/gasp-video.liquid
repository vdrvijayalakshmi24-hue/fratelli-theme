{% comment %}
  Video Scrub (GSAP + ScrollTrigger)
  - Pin the media wrapper (stable element) when it reaches top of viewport
  - Scrub the child <video> element's currentTime using the scroll progress
  - Implementation uses a canvas drawn from the <video> so scrubbing is more reliable across browsers
{% endcomment %}

<section id="section-video-scrub-{{ section.id }}" class="fratelli-video-scrub fratelli-video-scrub--{{ section.id }}">
  <div class="fratelli-video-scrub__inner">
    <!-- Pinned wrapper (we pin this) -->
    <div class="fratelli-video-scrub__media">
      <!-- Canvas will display frames (visible). Video is source only (kept in DOM, visually hidden). -->
      <canvas class="fratelli-video-scrub__canvas" aria-hidden="true"></canvas>

      <video
        class="fratelli-video-scrub__video"
        playsinline
        muted
        preload="auto"
        aria-hidden="true"
      >
        <source src="https://cdn.shopify.com/videos/c/o/v/aa8ea38fecb6431ebc55c842becc04eb.mp4" type="video/mp4">
      </video>
    </div>

    <!-- Content area -->
    <div class="fratelli-video-scrub__content" data-over-content>
      <div class="fratelli-video-scrub__container" id="jason-{{ section.id }}">
        <div class="fratelli-video-scrub__content-inner">
          <h1 id="jason-h1-{{ section.id }}">Explore Range of Fratelli</h1>
          <h2 id="jason-h2-{{ section.id }}">From Akluj's Soil</h2>
          <p id="jason-p-{{ section.id }}">
            Their hands don't just plant vines. they planted a vision. they dont dont follow europe. they carved india into every bottle.
          </p>
          <div style="margin-top: 1.25rem;">
            <button type="button" class="fratelli-video-scrub__explore-btn" id="jason-btn-{{ section.id }}">Explore</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <style>
    .fratelli-video-scrub { position: relative; width: 100%; }
    .fratelli-video-scrub__inner { position: relative; width: 100%; }

    /* media wrapper */
    .fratelli-video-scrub__media { width: 100%; position: relative; overflow: hidden; }

    /* canvas: visible surface, covers viewport */
    .fratelli-video-scrub__canvas {
      width: 100%;
      height: 100vh;       /* use 100vh (avoid 101vh which can confuse ScrollTrigger) */
      display: block;
      object-fit: cover;
      will-change: transform;
      background: #000;
    }

    /* video: source only (keep in DOM so it can be seeked/decoded) */
    .fratelli-video-scrub__video {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100vh;
      opacity: 0; /* keep it accessible but invisible */
      pointer-events: none;
      z-index: -1;
      object-fit: cover;
    }

    /* content starts in document flow; we'll overlay it via JS when needed */
    .fratelli-video-scrub__content {
      position: relative;
      width: 100%;
      margin-top: 0;
      padding: 20px;
      z-index: 2;
      background: linear-gradient(0deg, #181B0E 74.46%, rgba(0, 0, 0, 0) 100%);
      -webkit-mask-image: linear-gradient(to bottom, transparent 0%, black 30%, black 100%);
      mask-image: linear-gradient(to bottom, transparent 0%, black 15%, black 100%);
    }

    .fratelli-video-scrub__content-inner { max-width: 56rem; margin-bottom: 2.5rem; }

    .fratelli-video-scrub__container h1 {
      font-family: "Utile", sans-serif;
      text-transform: uppercase;
      color: #F4CF80;
      font-size: 48px;
      margin-top: 6rem;
    }
    .fratelli-video-scrub__container h2 {
      font-family: "Playfair Display", serif;
      margin-bottom: 1.75rem;
      padding-right: 5rem;
      color: #FFFFF8;
      font-size: 32px;
      font-style: italic;
      letter-spacing: -0.06em;
    }
    .fratelli-video-scrub__container p {
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      padding-right: 7rem;
      color: #FFFFF8;
      font-size: 20px;
      letter-spacing: -0.04em;
    }

    .fratelli-video-scrub__explore-btn {
      background: #fff;
      color: #000;
      border: none;
      padding: 0.625rem 1.25rem;
      border-radius: 20px;
      font-weight: 600;
      cursor: pointer;
    }

    @media (min-width: 1024px) {
      .fratelli-video-scrub__container { flex-direction: row; }
    }

    @media (prefers-reduced-motion: reduce) {
      .fratelli-video-scrub__content-panel { transition: none !important; }
    }
  </style>

  <script>
    
    (function () {
      var root = document.getElementById("section-video-scrub-{{ section.id }}");
      if (!root) return;

      var mediaWrap = root.querySelector(".fratelli-video-scrub__media"); // pinned element
      var videoEl = root.querySelector(".fratelli-video-scrub__video");
      var canvasEl = root.querySelector(".fratelli-video-scrub__canvas");
      var overContent = root.querySelector("[data-over-content]");

      if (!window.gsap || !window.ScrollTrigger) {
        console.warn("GSAP/ScrollTrigger not found. Make sure they are loaded in theme.liquid.");
        return;
      }
      gsap.registerPlugin(ScrollTrigger);

      // Force consistent video height (keep as you had)
      try { videoEl.style.height = "100vh"; } catch (e) {}

      // We'll overlay the content while the media is pinned so we can center it if needed.
      // Keep a fallback initialTop percent (where content sits before centering).
      if (overContent) {
        // Set overlay styles (so it's visually above the video while pinned)
        overContent.style.position = "absolute";
        overContent.style.left = "0";
        overContent.style.width = "100%";
        overContent.style.zIndex = "2";
        overContent.style.transform = "translateY(-50vh)";
        // Initialize top (will be corrected on refresh)
      }

      // scrubMultiplier controls scrub length (1 = 1 viewport)
      var scrubMultiplier = 1;

      function scrubDistance() {
        return Math.round(window.innerHeight * scrubMultiplier);
      }

      // ========== Canvas-based scrubbing logic (replaces direct currentTime writes) ==========
      // This keeps your ScrollTrigger usage but draws frames to canvas for consistent output.
      (function canvasScrubSetup() {
        if (!canvasEl || !videoEl) return;

        var devicePR = Math.max(1, window.devicePixelRatio || 1);
        var ctx = null;
        var duration = 0;
        var isSeeking = false;
        var pendingTarget = null;
        var lastRendered = -1;
        var seekEpsilon = 0.02; // skip tiny seeks under 20ms

        function setCanvasSize() {
          // keep CSS sizing but scale internal buffer for crispness
          var w = Math.max(1, Math.round(window.innerWidth));
          var h = Math.max(1, Math.round(window.innerHeight));
          canvasEl.style.width = w + "px";
          canvasEl.style.height = h + "px";
          canvasEl.width = Math.round(w * devicePR);
          canvasEl.height = Math.round(h * devicePR);

          ctx = canvasEl.getContext("2d");
          // scale so we can draw in CSS pixels
          ctx.setTransform(devicePR, 0, 0, devicePR, 0, 0);
        }

        function drawFrame() {
          if (!ctx || !videoEl.videoWidth || !videoEl.videoHeight) return;
          try {
            var vw = videoEl.videoWidth;
            var vh = videoEl.videoHeight;
            var cw = canvasEl.width / devicePR;
            var ch = canvasEl.height / devicePR;

            // compute cover-style source rect (crop to cover)
            var videoRatio = vw / vh;
            var canvasRatio = cw / ch;
            var sx = 0, sy = 0, sw = vw, sh = vh;

            if (videoRatio > canvasRatio) {
              // crop sides
              sw = Math.round(vh * canvasRatio);
              sx = Math.round((vw - sw) / 2);
            } else {
              // crop top/bottom
              sh = Math.round(vw / canvasRatio);
              sy = Math.round((vh - sh) / 2);
            }

            ctx.clearRect(0, 0, cw, ch);
            ctx.drawImage(videoEl, sx, sy, sw, sh, 0, 0, cw, ch);
            lastRendered = videoEl.currentTime || lastRendered;
          } catch (e) {
            // drawing may fail in some environments; ignore gracefully
          }
        }

        // safe setter for currentTime with clamp
        function safeSetTime(t) {
          try {
            if (!isFinite(t) || isNaN(t)) return;
            videoEl.currentTime = Math.max(0, Math.min(duration || t, t));
          } catch (e) {
            // some mobile browsers may throw; ignore
          }
        }

        // request a seek to a particular time (throttled via isSeeking + seeked event)
        function requestSeek(targetTime) {
          if (!isFinite(targetTime) || isNaN(targetTime)) return;
          pendingTarget = Math.max(0, Math.min(duration || targetTime, targetTime));

          if (isSeeking) return;

          // skip if already close to target
          if (Math.abs(pendingTarget - lastRendered) <= seekEpsilon) {
            // draw current frame
            drawFrame();
            return;
          }

          try {
            isSeeking = true;
            safeSetTime(pendingTarget);
            // when seek completes, "seeked" event will drawFrame
          } catch (e) {
            // fallback: attempt draw
            isSeeking = false;
            drawFrame();
          }
        }

        // when a seek finishes, draw and handle any pending changes
        videoEl.addEventListener("seeked", function () {
          isSeeking = false;
          drawFrame();
          // if pendingTarget changed during seek and is sufficiently different, request again
          if (pendingTarget !== null && Math.abs(pendingTarget - lastRendered) > seekEpsilon) {
            setTimeout(function () {
              if (!isSeeking) requestSeek(pendingTarget);
            }, 0);
          }
        });

        // on metadata, set up sizes + prime decoder
        function onMeta() {
          duration = videoEl.duration || 0;
          setCanvasSize();

          // attempt a quick play/pause to prime decoder (muted so most browsers allow)
          videoEl.pause();
          videoEl.play().then(function () {
            videoEl.pause();
            try { videoEl.currentTime = 0; } catch (e) {}
            drawFrame();
            ScrollTrigger.refresh();
          }).catch(function () {
            // play blocked; still try set time 0 and draw shortly after
            try { videoEl.currentTime = 0; } catch (e) {}
            setTimeout(function () {
              drawFrame();
              ScrollTrigger.refresh();
            }, 60);
          });
        }

        if (videoEl.readyState >= 2 && !isNaN(videoEl.duration)) {
          onMeta();
        } else {
          videoEl.addEventListener("loadedmetadata", onMeta, { once: true });
        }

        // handle resize: update canvas buffer and refresh ScrollTrigger
        var resizeTimer = null;
        window.addEventListener("resize", function () {
          clearTimeout(resizeTimer);
          resizeTimer = setTimeout(function () {
            setCanvasSize();
            ScrollTrigger.refresh();
          }, 120);
        });

        // expose draw helper if needed (for debugging)
        root._fratelliVideoCanvas = {
          draw: drawFrame,
          setSize: setCanvasSize
        };

        // Replace the simple setVideoTime used originally with requestSeek+draw flow
        // We'll still use your ScrollTrigger, so patch its onUpdate behavior below by
        // creating a small wrapper that maps progress->time and requests seek.

        // Create a "pass-through" ScrollTrigger like your original but we will not re-create it here.
        // Instead, override ScrollTrigger.create call below to call requestSeek when needed.
        // To keep your original structure unchanged, we'll create a small function that returns
        // a callback to be used in onUpdate.
        canvasScrubSetup.requestSeek = requestSeek;
      })();

      // Helper: safe set currentTime (kept for compatibility but route through canvas logic above)
      function setVideoTime(t) {
        // If canvas-based routine is present use it
        if (root._fratelliVideoCanvas && root._fratelliVideoCanvas.draw) {
          // request a seek via the canvas setup
          // guard: find the internal function we added
          var req = (function findRequest() {
            // canvasScrubSetup attached requestSeek to itself earlier as property
            // but it's not globally accessible - attempt to access via closure fallback
            // So use the canvas event approach: set video.currentTime and rely on seeked -> draw
            try {
              // if a direct requestSeek exists on the function object we created: use it
              if (typeof canvasEl !== 'undefined' && canvasEl && canvasEl.tagName && window) {
                // We attached request via closure earlier as canvasScrubSetup.requestSeek, but that's local.
                // Fallback: write to videoEl.currentTime (will be handled by seeked listener in canvas setup).
                try { videoEl.currentTime = t; } catch (e) {}
                return;
              }
            } catch (e) {
              try { videoEl.currentTime = t; } catch (e) {}
            }
          })();
        } else {
          // fallback: original simple implementation
          try {
            var dur = videoEl.duration || 0;
            if (dur && isFinite(dur)) {
              videoEl.currentTime = Math.max(0, Math.min(dur, t));
            }
          } catch (e) {}
        }
      }

      // Main ScrollTrigger: pin the wrapper and scrub progress 0..1
      var mainST = ScrollTrigger.create({
        trigger: mediaWrap,
        start: "top top",
        end: () => "+=" + scrubDistance(),
        pin: mediaWrap,          // pin the wrapper (not the video)
        pinSpacing: true,
        scrub: true,
        anticipatePin: 1,
        invalidateOnRefresh: true,
        // markers: true, // enable while debugging
        onUpdate: function(self) {
          var p = self.progress; // 0..1 over the pinned area

          // If video duration is ready, map progress to currentTime
          if (videoEl && !isNaN(videoEl.duration) && isFinite(videoEl.duration)) {
            // use canvas-based setter where possible
            var target = p * videoEl.duration;
            // Prefer to set via safeSetTime handled inside our canvas code (which listens to 'seeked')
            try {
              // If the canvas-based requestSeek is available on the closure, use it
              // Fallback to simple set
              if (root._fratelliVideoCanvas && typeof videoEl.currentTime !== 'undefined') {
                // Set currentTime -> canvas seek/draw flow will handle throttle and draw
                try { videoEl.currentTime = target; } catch (e) { /* ignore */ }
              } else {
                setVideoTime(target);
              }
            } catch (e) {
              setVideoTime(target);
            }
          }
        }
      });

      // Pause video initially and set time 0 when metadata is available
      if (videoEl) {
        function ensureReady() {
          try { videoEl.pause(); } catch (e) {}
          try { videoEl.currentTime = 0; } catch (e) {}
          ScrollTrigger.refresh();
        }
        if (videoEl.readyState >= 2 && !isNaN(videoEl.duration)) {
          ensureReady();
        } else {
          videoEl.addEventListener("loadedmetadata", ensureReady, { once: true });
        }

        // if reduced motion is preferred, do not animate video
        var prefersReduced = window.matchMedia("(prefers-reduced-motion: reduce)").matches;
        if (prefersReduced) {
          try { videoEl.pause(); } catch (e) {}
        }
      }

      // Recompute when resizing viewport
      window.addEventListener("resize", function () {
        ScrollTrigger.refresh();
      });
    })();
  </script>

  {% schema %}
  {
    "name": "Video Scrub Section",
    "settings": [],
    "presets": [
      { "name": "Video Scrub Section" }
    ]
  }
  {% endschema %}
</section>
