{% comment %}
  sections/first-video-and-content.liquid
  - Canvas-based video scrub section (user's FirstVideo) + content (FullSceenVideoContent).
  - This variant: continuous two-way scrub, exact duration handling, flicker fixes.
  - Replace the <source> with your {{ 'Video_2.mp4' | asset_url }} if needed.
{% endcomment %}

<section id="first-video-section-{{ section.id }}" class="first-video-section" data-section-id="{{ section.id }}">
  <style>
    /* ---------- Layout / scrub section ---------- */
    .first-vd-wrapper { position: relative; height: 200vh; width: 100%; overflow: visible; box-sizing: border-box; background: #000; }
    .first-vd-pin { position: absolute; top: 0; left: 0; right: 0; height: 100vh; width: 100%; z-index: 0; overflow: hidden; background: #000; }
    .first-vd-canvas { width: 100%; height: 100%; display: block; object-fit: cover; background: #000; image-rendering: auto; }
    .first-vd-video-decoder { position: absolute; opacity: 0; pointer-events: none; width: 1px; height: 1px; left: -9999px; top: -9999px; }
    .first-vd-spacer { height: 1px; }

    /* ---------- Content area ---------- */
    .first-video-content { position: relative; z-index: 10; box-sizing: border-box; width: 100%; overflow: hidden; padding: 0 20px; }
    .jason { position: relative; z-index: 10; margin-top: 5rem; display: flex; flex-direction: column; gap: 1.25rem; overflow-x: hidden; width: 100%; box-sizing: border-box; color: #FFFFF8; transform: translateY(40px); opacity: 0; }
    @media (max-width: 768px) { .jason h1 { margin-top: 0 !important; } }
    @media (max-width: 1023px) { .jason img { min-width: auto; max-width: 100%; height: auto; } .jason h1 { margin-top: 0rem; } }
    @media (min-width: 1024px) { .jason { flex-direction: row; } .first-video-content { padding: 0; } .jason img { min-width: 700px; } }
    .jason-content { max-width: 56rem; margin-bottom: 2.5rem; }
    .jason h1 { font-family: "Utile", sans-serif; text-transform: uppercase; color: #F4CF80; font-size: 48px; margin-top: 6rem; }
    .jason p { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; padding-right: 7rem; color: #FFFFF8; font-size: 20px; letter-spacing: -0.04em; }
    .explore-btn { background: #fff; color: #000; border: none; padding: 0.625rem 1.25rem; border-radius: 20px; font-weight: 600; cursor: pointer; }
    .content-1 { position: relative; display: block; background: linear-gradient(0deg, #181B0E 74.46%, rgba(0, 0, 0, 0) 100%); -webkit-mask-image: linear-gradient(to bottom, transparent 0%, black 30%, black 100%); mask-image: linear-gradient(to bottom, transparent 0%, black 15%, black 100%); box-sizing: border-box; }
    .full-image { width: 100%; height: 100vh; object-fit: cover; display: block; }
  </style>

  <!-- ========== Scrub section (canvas + hidden video) ========== -->
  <section class="first-vd-wrapper" id="first-vd-wrapper-{{ section.id }}" data-track-vh="250">
    <div class="first-vd-pin" id="first-vd-pin-{{ section.id }}">
      <canvas id="first-vd-canvas-{{ section.id }}" class="first-vd-canvas" role="img" aria-label="Video scrub"></canvas>
      <video
        id="first-vd-video-{{ section.id }}"
        class="first-vd-video-decoder"
        muted
        playsinline
        preload="auto"
        webkit-playsinline
        x-webkit-airplay="allow"
      >
        <!-- replace with your asset helper if you want -->
        <source src="https://cdn.shopify.com/videos/c/o/v/aa8ea38fecb6431ebc55c842becc04eb.mp4" type="video/mp4" />
        Your browser does not support the video tag.
      </video>
    </div>
    <div class="first-vd-spacer" aria-hidden="true"></div>
  </section>

  <!-- ========== Content area ========== -->
  <section class="first-video-content content-1" id="first-video-content-{{ section.id }}">
    <div class="jason" id="jason-{{ section.id }}">
      <div class="json-image" style="opacity: 1;">
        <img src="https://cdn.shopify.com/s/files/1/0491/6628/7016/files/Section_1.jpg?v=1758619356" alt="Fratelli Wines" width="700" height="532" style="object-fit: cover; margin-top: 6rem;" loading="lazy">
      </div>
      <div class="jason-content">
        <h1 id="jason-h1-{{ section.id }}">India’s finest Wine Makers</h1>
        <p id="jason-p-{{ section.id }}">From the heart of Akluj to tables across the world, Fratelli is more than wine, it’s a story of heritage, craftsmanship and seven brothers bound by a dream. Every bottle is a testament to passion and the spirit of Pour More Into Life.</p>
        <div style="margin-top: 1.25rem;"><button type="button" class="explore-btn" id="jason-btn-{{ section.id }}">Explore</button></div>
      </div>
    </div>
  </section>

  <script>
    (function () {
      var sectionId = '{{ section.id }}';

      /* ---------------- helper to load scripts once ---------------- */
      function loadScriptOnce(src) {
        return new Promise(function (resolve, reject) {
          if (document.querySelector('script[src="' + src + '"]')) { resolve(); return; }
          var s = document.createElement('script');
          s.src = src;
          s.async = true;
          s.onload = resolve;
          s.onerror = reject;
          document.head.appendChild(s);
        });
      }

      /* ---------------- Improved continuous two-way scrub (no flicker) ---------------- */
      (function improvedScrub() {
        var wrapper = document.getElementById('first-vd-wrapper-' + sectionId);
        var pin = document.getElementById('first-vd-pin-' + sectionId);
        var canvas = document.getElementById('first-vd-canvas-' + sectionId);
        var video = document.getElementById('first-vd-video-' + sectionId);
        if (!wrapper || !pin || !canvas || !video) return;

        // explicit non-looping
        try { video.loop = false; } catch (e) {}

        var ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });
        var duration = 0;
        var isSeeking = false;
        var pendingTime = null;
        var lastRenderedTime = -1; // remember last drawn time
        var SEEK_EPS = 0.02; // seconds threshold to avoid tiny seeks that cause flicker
        var rafId = null;

        function clamp(v, a, b) { return Math.min(b, Math.max(a, v)); }

        function drawFrameIfNeeded(timeToDraw) {
          // avoid re-drawing identical frames repeatedly
          if (typeof timeToDraw === 'number' && Math.abs(timeToDraw - lastRenderedTime) < SEEK_EPS) return;
          lastRenderedTime = timeToDraw;
          try { ctx.drawImage(video, 0, 0, canvas.width, canvas.height); } catch (e) {}
        }

        function onSeeked() {
          isSeeking = false;
          // queue a draw on rAF to ensure decoded frame is ready
          if (rafId) cancelAnimationFrame(rafId);
          rafId = requestAnimationFrame(function () {
            drawFrameIfNeeded(video.currentTime);
            rafId = null;
            if (pendingTime !== null) {
              var next = pendingTime;
              pendingTime = null;
              // if change is significant, issue another seek
              if (Math.abs(next - video.currentTime) > SEEK_EPS) seek(next);
            }
          });
        }

        function seek(t) {
          // clamp and check delta to avoid micro seeks which cause flicker
          var target = clamp(t, 0, Math.max(0, duration || 0));
          if (!isFinite(target)) target = 0;
          var delta = Math.abs(target - (video.currentTime || 0));
          if (delta < SEEK_EPS) {
            // small change -> just draw (no seek)
            drawFrameIfNeeded(target);
            return;
          }
          isSeeking = true;
          try {
            if (typeof video.fastSeek === 'function') video.fastSeek(target);
            else video.currentTime = target;
          } catch (e) {
            // fallback to setting currentTime directly; some browsers may throw
            try { video.currentTime = target; } catch (e) { isSeeking = false; }
          }
        }

        function sizeCanvas() {
          var vw = pin.clientWidth || window.innerWidth;
          var vh = pin.clientHeight || window.innerHeight;
          var vidW = video.videoWidth || vw;
          var vidH = video.videoHeight || vh;
          var vidRatio = (vidW && vidH) ? vidW / vidH : vw / vh;

          var canvasW = vw;
          var canvasH = Math.round(canvasW / vidRatio);

          if (canvasH < vh) {
            canvasH = vh;
            canvasW = Math.round(canvasH * vidRatio);
          }

          canvas.width = canvasW;
          canvas.height = canvasH;
          // redraw current frame
          drawFrameIfNeeded(video.currentTime || 0);
        }

        function createScrollTrigger() {
          if (!window.gsap || !window.ScrollTrigger) return;
          var gsap = window.gsap;
          var ScrollTrigger = window.ScrollTrigger;
          gsap.registerPlugin(ScrollTrigger);

          duration = video.duration || 0;
          if (!duration || !isFinite(duration)) duration = 0;

          sizeCanvas();

          var trackLength = Math.max(0, wrapper.offsetHeight - window.innerHeight);

          // kill previous triggers for wrapper/pin (prevents duplicates)
          ScrollTrigger.getAll().forEach(function (st) {
            if (st.trigger === wrapper || st.trigger === pin) {
              try { st.kill(); } catch (e) {}
            }
          });

          // direct mapping: scrub:true so scroll -> progress 1:1
          gsap.to({}, {
            ease: "none",
            duration: 1,
            scrollTrigger: {
              trigger: wrapper,
              start: "top top",
              end: "+=" + trackLength,
              scrub: true,
              pin: pin,
              invalidateOnRefresh: true,
              onUpdate: function (self) {
                var p = clamp(self.progress, 0, 1);
                var targetTime = p * duration;

                // if near the ends, explicitly set/pause to avoid any play attempts
                if (targetTime <= SEEK_EPS) {
                  // go to exact 0 and pause
                  pendingTime = null;
                  seek(0);
                  try { video.pause(); } catch (e) {}
                  return;
                }
                if (targetTime >= duration - SEEK_EPS) {
                  pendingTime = null;
                  seek(duration);
                  try { video.pause(); } catch (e) {}
                  return;
                }

                // normal case: if seeking in progress, store pending; otherwise seek
                if (isSeeking) {
                  pendingTime = targetTime;
                } else {
                  seek(targetTime);
                }
              },
              onRefresh: function () {
                sizeCanvas();
              }
            }
          });

          // ensure first frame
          if (duration > 0) seek(0);
        }

        function onLoadedMetadata() {
          duration = video.duration || 0;
          if (!duration || !isFinite(duration)) duration = 0;
          sizeCanvas();

          // avoid starting native playback; instead prepare decoder by a play/pause attempt if allowed (quiet)
          try {
            var p = video.play();
            if (p && typeof p.then === 'function') {
              p.then(function () { try { video.pause(); } catch (e) {} }).catch(function () {});
            } else { try { video.pause(); } catch (e) {} }
          } catch (e) {}

          video.addEventListener('seeked', onSeeked);
          createScrollTrigger();
        }

        // events
        window.addEventListener('resize', function () { sizeCanvas(); if (window.gsap && window.ScrollTrigger) try { window.ScrollTrigger.refresh(); } catch (e) {} });
        video.addEventListener('loadedmetadata', onLoadedMetadata);

        // If metadata already loaded at injection time
        if (video.readyState >= 1 && video.duration) {
          onLoadedMetadata();
        } else {
          try { video.load(); } catch (e) {}
        }

        function cleanup() {
          try { video.removeEventListener('loadedmetadata', onLoadedMetadata); } catch (e) {}
          try { video.removeEventListener('seeked', onSeeked); } catch (e) {}
          try { window.removeEventListener('resize', sizeCanvas); } catch (e) {}
          if (rafId) cancelAnimationFrame(rafId);
          if (window.gsap && window.ScrollTrigger) {
            try {
              window.ScrollTrigger.getAll().forEach(function (st) {
                if (st.trigger === wrapper || st.trigger === pin) {
                  try { st.kill(); } catch (e) {}
                }
              });
            } catch (e) {}
          }
        }

        if (window.Shopify && window.Shopify.designMode) {
          window.addEventListener('shopify:section:unload', cleanup);
          window.addEventListener('shopify:section:load', function () {
            setTimeout(function () {
              if (video.readyState >= 1) onLoadedMetadata();
              else try { video.load(); } catch (e) {}
            }, 60);
          });
        }
        window.addEventListener('pagehide', cleanup);
        window.addEventListener('beforeunload', cleanup);
      })();

      /* ------------------- Content GSAP animations (jason) ------------------- */
      (function contentGSAP() {
        var contentSection = document.getElementById('first-video-content-' + sectionId);
        if (!contentSection) return;

        var jason = contentSection.querySelector('#jason-' + sectionId) || contentSection.querySelector('.jason');
        var content1 = contentSection.classList.contains('content-1') ? contentSection : contentSection.querySelector('.content-1') || contentSection;
        var hasImage = !!contentSection.querySelector('.full-image');

        function loadScript(src) {
          return new Promise(function (resolve, reject) {
            if (document.querySelector('script[src="' + src + '"]')) return resolve();
            var s = document.createElement('script');
            s.src = src;
            s.onload = resolve;
            s.onerror = reject;
            document.head.appendChild(s);
          });
        }

        var GSAP_CDN = "https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js";
        var SCROLLTRIGGER_CDN = "https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js";

        function init() {
          if (!window.gsap || !window.ScrollTrigger) return console.warn('GSAP/ScrollTrigger not available for content animation.');
          gsap.registerPlugin(ScrollTrigger);

          var initialMargin = hasImage ? '-15vh' : '-62vh';
          try { content1.style.marginTop = initialMargin; } catch (e) {}
          try { gsap.set(jason, { y: 40, opacity: 0 }); } catch (e) {}

          try {
            gsap.to(jason, {
              y: 0,
              opacity: 1,
              duration: 1,
              ease: "power1.inOut",
              scrollTrigger: {
                trigger: content1,
                start: "top 90%",
                end: "100% center",
                scrub: 2
              }
            });
          } catch (e) { console.warn('jason animation error', e); }
        }

        if (window.gsap && window.ScrollTrigger) { init(); }
        else {
          loadScript(GSAP_CDN)
            .then(function () { return loadScript(SCROLLTRIGGER_CDN); })
            .then(function () { setTimeout(init, 40); })
            .catch(function (err) { console.error('Failed to load GSAP for content animation', err); });
        }
      })();

    })();
  </script>

  {% schema %}
  {
    "name": "First Video Canvas Scrub",
    "settings": [],
    "blocks": [],
    "max_blocks": 1,
    "presets": [{"name": "First Video Canvas Scrub"}]
  }
  {% endschema %}
</section>
