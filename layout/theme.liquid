<!doctype html>

<html class="no-js" lang="{{ shop.locale }}">
  <head>
    <meta charset="utf-8"> 
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, height=device-height, minimum-scale=1.0, maximum-scale=1.0">
    <meta name="theme-color" content="{{ settings.accent_color }}">
    <meta name="facebook-domain-verification" content="f7cq4hq8kdks12wuzcbj23u9wkagan" />

    <title>
      {{ page_title }}{% if current_tags %}{% assign meta_tags = current_tags | join: ', ' %} &ndash; {{ 'general.meta.tags' | t: tags: meta_tags }}{% endif %}{% if current_page != 1 %} &ndash; {{ 'general.meta.page' | t: page: current_page }}{% endif %}{% unless page_title contains shop.name %} &ndash; {{ shop.name }}{% endunless %}
    </title>

    {%- if page_description -%}
      <meta name="description" content="{{ page_description | escape }}">
    {%- endif -%}

    <link rel="canonical" href="{{ canonical_url }}">

    {%- if settings.favicon -%}
      <link rel="shortcut icon" href="{{ settings.favicon | img_url: '96x' }}" type="image/png">
    {%- endif -%}

    {% render 'social-meta-tags' %}
    {% render 'css-variables' %}

    {{ content_for_header }}
  {% include 'tipo.booking.script' %}
  
    <!-- GSAP Animation Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>
    <script src="https://unpkg.com/lenis@1.3.11/dist/lenis.min.js"></script>
    <script>
      // Initialize GSAP and register plugins
      if (window.gsap) {
        try {
          gsap.registerPlugin(ScrollTrigger);
          
          // Create global GSAP utilities if they don't exist
          window.FratelliGSAP = window.FratelliGSAP || {};
          
          // Common GSAP animations
          window.FratelliGSAP.animateFadeIn = function(element, delay = 0, y = 40, duration = 1) {
            if (!element) return null;
            
            gsap.set(element, { y: y, opacity: 0 });
            return gsap.to(element, {
              y: 0,
              opacity: 1,
              duration: duration,
              delay: delay,
              ease: "power1.inOut",
              scrollTrigger: {
                trigger: element,
                start: "top 90%",
                end: "100% center",
                scrub: 2
              }
            });
          };
          
          window.FratelliGSAP = window.FratelliGSAP || {};

window.FratelliGSAP.initVideoScrub = function (options) {
  const {
    wrapperId,
    pinId,
    canvasId,
    videoId,
    onReady = () => {},
    onUpdate = () => {},
    debug = false, // set to true to see console logs for debugging
  } = options;

  const wrapper = document.getElementById(wrapperId);
  const pin = document.getElementById(pinId);
  const canvas = document.getElementById(canvasId);
  const video = document.getElementById(videoId);

  if (!wrapper || !pin || !canvas || !video) {
    console.warn('Video scrub elements not found');
    return null;
  }

  // ensure mobile-friendly attributes
  try {
    video.muted = true;
    video.playsInline = true;
    video.setAttribute && video.setAttribute('playsinline', '');
    video.setAttribute && video.setAttribute('webkit-playsinline', '');
    video.preload = 'auto';
  } catch (e) {}

  const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });
  ctx.imageSmoothingEnabled = true;

  // constants
  const STEP = 1 / 60; // quantize to 60Hz
  const DRAW_FALLBACK_DELAY = 25; // ms: fallback draw after setting currentTime if 'seeked' doesn't fire quickly
  const DEBUG = !!debug;

  // state
  let duration = 0;
  let startY = 0;
  let endY = 0;

  // loop control
  let rafId = null;
  let visible = false; // section visibility (IntersectionObserver)
  let lastRequestedTime = -1;
  let lastDrawTs = 0;

  function dbg(...args) { if (DEBUG) console.log('[scrub]', ...args); }

  function clamp(v, a, b) { return Math.min(b, Math.max(a, v)); }

  function setAbsoluteAt(y) {
    pin.style.position = 'absolute';
    pin.style.top = y + 'px';
    pin.style.left = '0';
    pin.style.right = '0';
    pin.style.height = '100vh';
    pin.style.width = '100%';
  }

  function updatePin() {
    const rect = wrapper.getBoundingClientRect();
    const vh = window.innerHeight || document.documentElement.clientHeight;
    if (rect.top > 0) return setAbsoluteAt(0);
    if (rect.bottom <= vh) return setAbsoluteAt(wrapper.offsetHeight - vh);

    pin.style.position = 'fixed';
    pin.style.top = '0';
    pin.style.left = '0';
    pin.style.right = '0';
    pin.style.height = '100vh';
    pin.style.width = '100%';
  }

  function measure() {
    const rect = wrapper.getBoundingClientRect();
    const pageY = window.pageYOffset || document.documentElement.scrollTop || 0;
    startY = pageY + rect.top;
    endY = startY + Math.max(1, wrapper.offsetHeight - window.innerHeight);
    updatePin();
  }

  function resizeCanvasToDisplaySize() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const wCss = canvas.clientWidth || window.innerWidth;
    const hCss = canvas.clientHeight || window.innerHeight;
    const w = Math.round(wCss * dpr);
    const h = Math.round(hCss * dpr);
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w;
      canvas.height = h;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
  }

  function draw() {
    try {
      ctx.clearRect(0, 0, canvas.clientWidth || window.innerWidth, canvas.clientHeight || window.innerHeight);
      ctx.drawImage(video, 0, 0, canvas.clientWidth || window.innerWidth, canvas.clientHeight || window.innerHeight);
      lastDrawTs = performance.now();
    } catch (e) {
      // ignore until frame available
    }
  }

  // Simple safe seek helper: set currentTime (fastSeek used if available).
  function seekTo(timeSec) {
    const t = clamp(timeSec, 0, Math.max(0, duration - 1e-6));
    if (Math.abs(t - lastRequestedTime) < 1e-6) {
      // no-op
      return;
    }
    lastRequestedTime = t;
    try {
      if (typeof video.fastSeek === 'function') {
        video.fastSeek(t);
      } else {
        video.currentTime = t;
      }
      // fallback draw in case 'seeked' doesn't fire quickly
      setTimeout(() => {
        // only draw if no new draw happened recently (prevents extra draws)
        if (performance.now() - lastDrawTs > DRAW_FALLBACK_DELAY) {
          draw();
          dbg('fallback draw after seek to', t);
        }
      }, DRAW_FALLBACK_DELAY);
    } catch (err) {
      dbg('seekTo error', err);
    }
  }

  // We'll use requestVideoFrameCallback when available to draw final presented frames
  let rvfcActive = false;
  function startRVFC() {
    if (typeof video.requestVideoFrameCallback === 'function' && !rvfcActive) {
      rvfcActive = true;
      const cb = (now, meta) => {
        draw();
        if (rvfcActive) video.requestVideoFrameCallback(cb);
      };
      try { video.requestVideoFrameCallback(cb); } catch (e) { rvfcActive = false; }
    }
  }
  function stopRVFC() { rvfcActive = false; }

  // IntersectionObserver to start/stop RAF while element visible.
  const io = new IntersectionObserver(entries => {
    entries.forEach(e => {
      visible = e.isIntersecting;
      dbg('visibility', visible);
      if (visible) {
        // make sure measurements are fresh then start loop
        measure();
        startLoop();
        startRVFC();
      } else {
        // stop loop when not visible to avoid mobile throttling issues
        stopLoop();
        stopRVFC();
      }
    });
  }, { threshold: 0.01 });
  io.observe(wrapper);

  // Seeked handler: draw once a seek finishes (many browsers)
  video.addEventListener('seeked', () => {
    draw();
    dbg('seeked -> draw', video.currentTime);
  });

  function tick() {
    // compute progress by reading wrapper position on every frame
    measure(); // subtle: keeps start/end accurate if layout changes as user scrolls
    const pageY = window.pageYOffset || document.documentElement.scrollTop || 0;
    const progRaw = (pageY - startY) / Math.max(1, endY - startY);
    const p = clamp(progRaw, 0, 1);
    const tRaw = p * duration;
    const tQuant = clamp(Math.round(tRaw / STEP) * STEP, 0, Math.max(0, duration - 1e-6));

    // Always attempt to set video.currentTime when visible and progress changed.
    // This makes scrub deterministic: scroll -> exact time.
    seekTo(tQuant);

    // call user update
    try { onUpdate(p, tQuant); } catch (e) {}

    // draw fallback for browsers without RVFC (we still rely on seeked for frames)
    // but ensure a draw each frame in case the browser's video element displays frame synchronously
    if (typeof video.requestVideoFrameCallback !== 'function') {
      draw();
    }

    rafId = requestAnimationFrame(tick);
  }

  function startLoop() {
    if (!rafId && visible) {
      rafId = requestAnimationFrame(tick);
      dbg('loop started');
    }
  }
  function stopLoop() {
    if (rafId) {
      cancelAnimationFrame(rafId);
      rafId = null;
      dbg('loop stopped');
    }
  }

  function onLoadedMeta() {
    duration = video.duration || 0;
    if (!duration || !isFinite(duration)) {
      console.warn('Invalid video duration, falling back to 1s');
      duration = 1;
    }
    video.pause(); // control time manually

    resizeCanvasToDisplaySize();
    measure();
    // initial sync to 0
    seekTo(0);
    draw();

    // start things only if wrapper visible (io will start loop), otherwise wait
    if (visible) {
      startLoop();
      startRVFC();
    }

    try { onReady({ duration, video, canvas }); } catch (e) {}
  }

  // attach loadedmetadata
  video.addEventListener('loadedmetadata', onLoadedMeta);

  // if metadata already available
  if (video.readyState >= 1) onLoadedMeta();
  else try { video.load(); } catch (e) {}

  // resize handling
  window.addEventListener('resize', () => {
    resizeCanvasToDisplaySize();
    measure();
    draw();
  });

  // expose a small debug method in case you want to poke from console
  const api = {
    stop() { stopLoop(); stopRVFC(); },
    start() { startLoop(); startRVFC(); },
    forceDraw() { draw(); },
    debugOn() { return dbg('debug on'); },
  };

  // return cleanup function (same public shape as original)
  return function cleanup() {
    stopLoop();
    stopRVFC();
    try { io.disconnect(); } catch (e) {}
    try { video.removeEventListener('loadedmetadata', onLoadedMeta); } catch (e) {}
    try { window.removeEventListener('resize', resizeCanvasToDisplaySize); } catch (e) {}
    dbg('cleanup done');
    return api;
  };
};






          
          console.log('GSAP initialized with FratelliGSAP utilities');
          
        } catch (e) {
          console.error('Error initializing GSAP utilities:', e);
        }
      } else {
        console.warn('GSAP not available. Some animations may not work.');
      }
      // Rockstar Games-style video scrubbing implementation
      let isVideoScrubbing = false;
      let scrollY = 0;
      let targetScrollY = 0;
      let lastTimestamp = 0;
      
      // Configuration
      const config = {
        scrollMultiplier: 1.0, // Adjust this based on your video length
        maxScrollDelta: 100,   // Maximum pixels to move per frame for smoothness
        touchScrollFactor: 1.5, // How much to multiply touch scroll by
        wheelScrollFactor: 0.5  // How much to multiply wheel scroll by
      };

      // Handle scroll events directly for video scrubbing
      function handleScroll(e) {
        if (!isVideoScrubbing) return;
        
        // Prevent default to stop default scrolling behavior
        e.preventDefault();
        
        let deltaY = 0;
        
        // Handle touch events
        if (e.type === 'touchmove' && e.touches.length === 1) {
          deltaY = -e.touches[0].clientY * config.touchScrollFactor;
        } 
        // Handle mouse wheel
        else if (e.type === 'wheel') {
          deltaY = e.deltaY * config.wheelScrollFactor;
        }
        
        // Update target scroll position
        targetScrollY += deltaY;
        
        // Clamp scroll position to valid range
        const maxScroll = document.documentElement.scrollHeight - window.innerHeight;
        targetScrollY = Math.max(0, Math.min(maxScroll, targetScrollY));
      }
      
      // Animation loop for smooth scrolling
      function animateScroll(timestamp) {
        if (!lastTimestamp) lastTimestamp = timestamp;
        const deltaTime = timestamp - lastTimestamp;
        lastTimestamp = timestamp;
        
        if (isVideoScrubbing) {
          // Smoothly interpolate towards target scroll position
          const diff = targetScrollY - scrollY;
          const direction = Math.sign(diff);
          const delta = Math.min(Math.abs(diff), config.maxScrollDelta * (deltaTime / 16));
          
          scrollY += direction * delta;
          
          // Update the actual scroll position
          window.scrollTo(0, scrollY);
          
          // Dispatch scroll event for other listeners
          window.dispatchEvent(new Event('scroll'));
        }
        
        requestAnimationFrame(animateScroll);
      }
      
      // Start the animation loop
      requestAnimationFrame(animateScroll);
      
      // Set up event listeners for video scrubbing
      function setupVideoScrubbing() {
        // Add passive: false to ensure we can preventDefault
        window.addEventListener('wheel', handleScroll, { passive: false });
        window.addEventListener('touchmove', handleScroll, { passive: false });
        
        // Initial setup
        scrollY = window.scrollY;
        targetScrollY = scrollY;
      }
      
      // Clean up event listeners
      function cleanupVideoScrubbing() {
        window.removeEventListener('wheel', handleScroll);
        window.removeEventListener('touchmove', handleScroll);
      }

      // Initial setup
      handleResize();
      window.addEventListener('resize', handleResize, { passive: true });
      window.addEventListener('orientationchange', handleResize, { passive: true });

      // Handle video scrub start/end events
      document.addEventListener('videoScrubStart', () => {
        isVideoScrubbing = true;
        setupVideoScrubbing();
        // Store current scroll position when starting to scrub
        scrollY = window.scrollY;
        targetScrollY = scrollY;
      });
      
      document.addEventListener('videoScrubEnd', () => {
        isVideoScrubbing = false;
        cleanupVideoScrubbing();
      });
      
      // Initialize scroll position tracking
      window.addEventListener('scroll', () => {
        if (!isVideoScrubbing) {
          scrollY = window.scrollY;
          targetScrollY = scrollY;
        }
      }, { passive: true });

      // Start the animation loop
      requestAnimationFrame(raf);

      // Handle mobile touch events better
      if ('ontouchstart' in window) {
        // Add passive: true for better touch performance
        document.addEventListener('touchstart', () => {}, { passive: true });
        document.addEventListener('touchmove', () => {}, { passive: true });
      }

      // Fix for iOS rubber-banding
      document.body.style.overscrollBehavior = 'none';
    </script>
    
    <link rel="stylesheet" href="{{ 'theme.css' | asset_url }}">
    <link rel="stylesheet" href="{{ 'custom-header.css' | asset_url }}" type="text/css">

    <script>
      // This allows to expose several variables to the global scope, to be used in scripts
      window.theme = {
        pageType: {{ request.page_type | json }},
        moneyFormat: {{ shop.money_format | json }},
        moneyWithCurrencyFormat: {{ shop.money_with_currency_format | json }},
        productImageSize: {{ settings.product_image_size | json }},
        searchMode: {{ settings.search_mode | json }},
        showPageTransition: {{ settings.show_page_transition | json }},
        showElementStaggering: {{ settings.show_element_staggering | json }},
        showImageZooming: {{ settings.show_image_zooming | json }}
      };

      window.routes = {
        rootUrl: {{ routes.root_url | json }},
        cartUrl: {{ routes.cart_url | json }},
        cartAddUrl: {{ routes.cart_add_url | json }},
        cartChangeUrl: {{ routes.cart_change_url | json }},
        searchUrl: {{ routes.search_url | json }},
        productRecommendationsUrl: {{ routes.product_recommendations_url | json }}
      };

      window.languages = {
        cartAddNote: {{ 'cart.general.add_note' | t | json }},
        cartEditNote: {{ 'cart.general.edit_note' | t | json }},
        productImageLoadingError: {{ 'product.slideshow.image_loading_error' | t | json }},
        productFormAddToCart: {% if product.template_suffix == 'pre-order' %}{{ 'product.form.pre_order' | t | json }}{% else %}{{ 'product.form.add_to_cart' | t | json }}{% endif %},
        productFormUnavailable: {{ 'product.form.unavailable' | t | json }},
        productFormSoldOut: {{ 'product.form.sold_out' | t | json }},
        shippingEstimatorOneResult: {{ 'cart.shipping_estimator.one_result_title' | t | json }},
        shippingEstimatorMoreResults: {{ 'cart.shipping_estimator.more_results_title' | t | json }},
        shippingEstimatorNoResults: {{ 'cart.shipping_estimator.no_results_title' | t | json }}
      };

      window.lazySizesConfig = {
        loadHidden: false,
        hFac: 0.5,
        expFactor: 2,
        ricTimeout: 150,
        lazyClass: 'Image--lazyLoad',
        loadingClass: 'Image--lazyLoading',
        loadedClass: 'Image--lazyLoaded'
      };

      document.documentElement.className = document.documentElement.className.replace('no-js', 'js');
      document.documentElement.style.setProperty('--window-height', window.innerHeight + 'px');

      // We do a quick detection of some features (we could use Modernizr but for so little...)
      (function() {
        document.documentElement.className += ((window.CSS && window.CSS.supports('(position: sticky) or (position: -webkit-sticky)')) ? ' supports-sticky' : ' no-supports-sticky');
        document.documentElement.className += (window.matchMedia('(-moz-touch-enabled: 1), (hover: none)')).matches ? ' no-supports-hover' : ' supports-hover';
      }());
    </script>

    <script src="{{ 'lazysizes.min.js' | asset_url }}" async></script>

    {%- if template == 'customers/addresses' -%}
      <script src="{{ 'shopify_common.js' | shopify_asset_url }}" defer></script>
      <script src="{{ 'customer_area.js' | shopify_asset_url }}" defer></script>
    {%- endif -%}

    <script src="https://cdn.polyfill.io/v3/polyfill.min.js?unknown=polyfill&features=fetch,Element.prototype.closest,Element.prototype.remove,Element.prototype.classList,Array.prototype.includes,Array.prototype.fill,Object.assign,CustomEvent,IntersectionObserver,IntersectionObserverEntry,URL" defer></script>
    <script src="{{ 'libs.min.js' | asset_url }}" defer></script>
    <script src="{{ 'theme.min.js' | asset_url }}" defer></script>
    <script src="{{ 'custom.js' | asset_url }}" defer></script>

    <script>
      (function () {
        window.onpageshow = function() {
          if (window.theme.showPageTransition) {
            var pageTransition = document.querySelector('.PageTransition');

            if (pageTransition) {
              pageTransition.style.visibility = 'visible';
              pageTransition.style.opacity = '0';
            }
          }

          // When the page is loaded from the cache, we have to reload the cart content
          document.documentElement.dispatchEvent(new CustomEvent('cart:refresh', {
            bubbles: true
          }));
        };
      })();
    </script>
 

    {% render 'microdata-schema' %}
  </head>

  {%- capture classes -%}features--heading-{{ settings.heading_size }}{%- endcapture -%}

  {%- if settings.uppercase_heading -%}
    {%- assign classes = classes | append: ' features--heading-uppercase' -%}
  {%- endif -%}

  {%- if settings.product_show_price_on_hover -%}
    {%- assign classes = classes | append: ' features--show-price-on-hover' -%}
  {%- endif -%}

  {%- if settings.show_page_transition -%}
    {%- assign classes = classes | append: ' features--show-page-transition' -%}
  {%- endif -%}

  {%- if settings.show_button_transition -%}
    {%- assign classes = classes | append: ' features--show-button-transition' -%}
  {%- endif -%}

  {%- if settings.show_image_zooming -%}
    {%- assign classes = classes | append: ' features--show-image-zooming' -%}
  {%- endif -%}

  {%- if settings.show_element_staggering -%}
    {%- assign classes = classes | append: ' features--show-element-staggering' -%}
  {%- endif -%}

  <body class="prestige--v4 {{ classes }} {% if template.directory %}template-{{ template.directory | handle }}{% endif %} template-{{ template.name | handle }} {% unless request.design_mode %}age-gate-loading{% endunless %}" data-age-gate-verified="{% if request.design_mode %}true{% else %}false{% endif %}">
    <a class="PageSkipLink u-visually-hidden" href="#main">{{ 'header.navigation.skip_to_content' | t }}</a>
    <span class="LoadingBar"></span>
    <div class="PageOverlay"></div>

    {%- if settings.show_page_transition -%}
      <div class="PageTransition"></div>
    {%- endif -%}

    {% section 'popup' %}
    {% section 'sidebar-menu' %}

    {%- if template != 'cart' -%}
      {% render 'cart-drawer' %}
    {%- endif -%}

    <div class="PageContainer">
      {% section 'announcement' %}
      {% section 'header' %}
      <div id="age-gate-section" style="display: none;">
      {% section 'age-gate' %}
      </div>
      
      <div id="page-content" style="display: none;">
        <main id="main" role="main">
          {{ content_for_layout }}
        </main>
        {% section 'footer' %}
      </div>
    </div>
    
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        const ageVerified = localStorage.getItem('agegateConfirmed_v1') === 'true';
        const body = document.body;
        const pageContent = document.getElementById('page-content');
        const ageGateSection = document.getElementById('age-gate-section');

        
        if (ageVerified || body.classList.contains('template-password')) {
          // If age is verified or it's the password page, show content and hide age gate
          if (pageContent) pageContent.style.display = 'block';
          if (ageGateSection) ageGateSection.style.display = 'none';
          body.classList.remove('age-gate-loading');
          body.setAttribute('data-age-gate-verified', 'true');
        } else {
          // Show age gate and hide content
          if (pageContent) pageContent.style.display = 'none';
          if (ageGateSection) ageGateSection.style.display = 'block';
          body.classList.add('age-gate-loading');
        }
      });
    </script>
    {% render 'bookthatapp-widgets' %}
  </body>
</html>
